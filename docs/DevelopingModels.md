# Model Development
Models represent entities that the RSIS framework can load, instantiate, and schedule.

## Language
A C++17 environment is exposed for model development.

## Ports
Ports are the method through which models are exposed to the framework. The top level of the model interface has a required structure with specific intent:
- in
    - Represents model inputs
    - Each `in` port can be connected to a single `out` port
- out
    - Represents model outputs
    - Can be connected to multiple `in` ports
- data
    - Exposes read-only internal state
- params
    - Parameters that can be set before sim initialization

Ports can additionally be further organized into logical groupings; these map directly to structs/classes in C++. Permissions and intent for these further subdivisions are inheritied from the top level breakdown.

## Code Generation
RSIS provides a YAML based interface code generate process to simplify the process of model development. The following are autogenerated:
- Model interface header file in C++
    - Contains class declarations
    - Contains function declarations for metadata passback to Julia
- Model interface source file in C++
    - Contains constructor/destructor definitions
    - Contains function definitions for metadata passback to Julia

Example model interface:
```yaml
model: Model

ModelIn:
  power: {type: float, value: 0.0, unit: V, desc: Voltage power input to model }

ModelOut:
    counter: {type: int32_t, dims: [2], value: 0, desc: Randomly increments when on }

ModelData:
    on: {type: bool, value: false, desc: Model On state }

ModelParams:
    turn_on: {type: float, value: 3.0, unit: V, desc: Base voltage requirement for turn on }

Model:
    in: {class: ModelIn }
    out: {class: ModelOut }
    data: {class: ModelData }
    params: {class: ModelParams }
```

The rest of this section will use C++ terminology. The interface file is required to have a `model` element, specifying another element in the file that is the root of the model interface definition. That class is required to have the following elements: `in`, `out`, `data`, `params`. Each class member definition must be a dictionary.

The `type` key in a member definition indicates that the datatype is one of the  supported C++ data types, as listed [here](#Default_Data_Types). The `class` key in a member definition indicates that the datatype is a user-defined type. The table below lists optional keys that can be defined.

| key  | Meaning | Definition | Example |
| ---- | ------- | ---------- | ------- |
| dims | Array dimension. Defaults to scalar | List of positive integers | [2,3,2] |
| unit | Units. Defaults to nothing | See [Units](#Units) | kg^2/m |
| desc | Description. Defaults to nothing | String | Jet engine thrust output |

The `value` key can also be specified for non user defined types, indicating a default value that the member must take.

### Planned Features
- Referencing other YAML files
- Pointer type definitions
- Possible additional datatype support:
    - `std::string`
    - `std::array<>`
    - `void *`
    - `char8_t` (C++20)
- Only adding `#include <complex>` when needed. Currently added always

### Default Data Types
The following C++ data types are supported alongside their associated Julia data type:
- `int8_t`, `int16_t`, `int32_t`, `int64_t`
    - Int8, Int16, Int32, Int64
- `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`
    - UInt8, UInt16, UInt32, UInt64
- `char`
    - Char
- `bool`
    - Bool
- `float`, `double`
    - Float32, Float64
- `std::complex<float>`, `std::complex<double>`
    - Complex{Float32}, Complex{Float64}

The lack of support for `int`, `short`, `long`, `long long`, and their unsigned equivalents is intentional.

### Units
The `Unitful` package is used to define units for ports. Connected ports that both have a defined unit must have matching units (this rule is relaxed if any or both ports don't have a unit). In order to convert between units, it is suggested that the user add a `Unit Conversion` block provided in the Framework Library.

The default symbols provided by `Unitful` are immediately available for model usage.

## Connecting Model Ports
Input & output model ports can be connected via the Julia `connect` command (See Julia help for more info), creating connection objects in the simulation run-time. During the simulation, the connection objects copy output port data to connected input ports, which are called by the models containing those inputs.


## Model Hooks
A variety of hooks are exposed for the user to extend:
- initModel
    - Called during initialization of the simulation. The user must extend this.
- configModel
    - Called when model parameters are updated.
    - Called once during each step of the simulation. The user must extend this.
- stepModel
- destroyModel
    - Called once during the end of the simulation

## Compilation
Models are compiled as shared libraries that are loaded in during runtime. The full C++ ABI is utilized, so it is highly recommended that models are compiled with the same compiler and C++ standard settings as the RSIS Framework itself.

## Model Port Pointers
Model input and output ports can be declared as pointer types, with the 

## Additional User Callbacks
TODO
