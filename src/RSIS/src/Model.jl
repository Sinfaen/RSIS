# Model Interface
# Used for exposing models & generating C++ interface code

module MModel

export Model, Port, Callback
export listcallbacks, triggercallback
export generateinterface
export load, unload

using ..MScripting
using ..MLibrary
using ..MLogging
using ..Unitful

# globals
_type_map = Dict(
    Int8   => "int8_t",
    Int16  => "int16_t",
    Int32  => "int32_t",
    Int64  => "int64_t",
    UInt8  => "uint8_t",
    UInt16 => "uint16_t",
    UInt32 => "uint32_t",
    UInt64 => "uint64_t",
    Bool   => "bool",
    Float32 => "float",
    Float64 => "double",
    Complex{Float32} => "std::complex<float>",
    Complex{Float64} => "std::complex<double>"
)

@enum PortType PORT=1 PORTPTR=2 PORTPTRI=3

"""
DefineS a Port in a Model Interface file
"""
struct Port
    type::Type
    dimension::Tuple
    defaultvalue::Any
    units::Any
    note::String
    porttype::PortType

    function Port(type::Type, dimension::Tuple, defaultvalue::Any; units::Any=nothing, note::String="", porttype::PortType=PORT)
        if eltype(defaultvalue) != type
            throw(ArgumentError("Provided type: $type does not match type of default value: $(eltype(defaultvalue))"))
        end
        _size = size(defaultvalue)
        if length(dimension) != length(_size)
            error("Provided dimension, [$dimension], does not match: $defaultvalue")
        end
        for i = 1:length(dimension)
            if dimension[i] != _size[i]
                error("Provided dimension, [$dimension], does not match: $defaultvalue")
            end
        end
        new(type, dimension, defaultvalue, units, note, porttype)
    end
end

"""
"""
struct Callback
    name::String
end

"""
References instantiated model in the simulation framework
"""
mutable struct Model
    name::String
    in::Vector{Any}
    out::Vector{Any}
    data::Vector{Any}
    params::Vector{Any}

    callbacks::Vector{Callback}
end

"""
    listcallbacks(model::Model)
List all callbacks provided by model instance
```jldoctest
julia> mymodel = createmodel("MyModel", "mymodel", group="test")
julia> listcallbacks(mymodel)
mymodel (MyModel) callbacks:
    > stepModel
    > step_1Hz
```
"""
function listcallbacks(model::Model)
    name = model.name
    println("$name callbacks:")
    for i in eachindex(model.callbacks)
        cb = model.callbacks[i].name
        println("    > $cb")
    end
end

"""
    triggercallback(model::Model, callback::String)
Trigger a specified callback in a model instance.
```jldoctest
julia> triggercallback(mymodel, "step_1Hz")
[mymodel.step_1Hz] executed successfully.
```
"""
function triggercallback(model::Model, callback::String)
    println("Not implemented")
end

"""
    load(library::String)
Load a shared library containing a model implementation
```jldoctest
julia> load("mymodel")
```
"""
function load(library::String) :: Nothing
    # Find library in search path, then pass absolute filepath
    # to core functionality
    locations = search(library)
    if length(locations) == 0
        throw(IOError("File not found: $(library)"))
    end

    if !LoadModelLib(library, locations[0])
        logmsg("Model library already loaded.", LOG)
    end
end

"""
    unload(library::String)
Unload a shared library containing a model implementation
```jldoctest
julia> load("mymodel")
julia> unload("mymodel")
julia> unload("mymodel")
Model library not previously loaded.
```
"""
function unload(library::String) :: Nothing
    if !UnloadModelLib(library)
        logmsg("Model library not previously loaded.", WARNING)
    end
end


function createmodel(model::String)
    println("Not implemented")
    # call core::LoadModel
end

function connect(output::String, input::String)
    println("Not implemented")
end

"""
Helper function for generateinterface
Used to create model files from relevant information
"""
function pushtexttofile(directory::String, model::String, append::String, text::String)
    path = joinpath(directory, model * append)
    print("Generating: $path")
    f_file = open(path, "w")

    write(f_file, "/* Autogenerated by RSIS Framework */\n")
    write(f_file, text)

    close(f_file)

    # use archaic ansi escape sequences to overwrite previous print
    print("\e[2K") # clear whole line
    print("\e[1G") # move cursor to column 1

    println("Generated: $path")
end

"""
Exception thrown when Model Interface doesn't match expectation
"""
struct InterfaceException <: Exception
    member::Symbol
    type::Type
end

Base.showerror(io::IO, e::InterfaceException) = print(io, "'$(e.member)' not found in $(e.type)")

function grabClassDefinitions(obj::Any,
                              type::DataType,
                              order::Vector,
                              definitions::Dict{String, Vector{Tuple{Symbol, Port}}})
    type_s = "$(type)"
    if !haskey(definitions, type_s)
        definitions[type_s] = Vector{Port}()
    end
    for (symb, type) in zip(fieldnames(type), type.types)
        if type == Port
            push!(definitions[type_s], (symb, getfield(obj, symb)))
        elseif type == Any
            throw(ErrorException("$(symb) is of type Any"))
        else
            memb_classname = "$(type)";
            if !(memb_classname in keys(definitions))
                push!(order, memb_classname) # appending at the back is better optimized
                grabClassDefinitions(getfield(obj, symb), type, order, definitions)
            end
        end
    end
end

"""
    generateinterface(interface::String)
Generate a C++ model interface from the specified interface file.
The generated files are put in the same location as the interface
file.
```jldoctest
julia> generateinterface("mymodel.jl")
Generated: mymodel_interface.hxx
Generated: mymodel_interface.cxx
Generation complete
```
"""
function generateinterface(interface::String)
    path_interface = search(interface)
    if length(path_interface) == 0
        throw(IOError("Unable to find interface file: $interface"))
    end

    type = include(path_interface[1])
    instance = Base.invokelatest(type)

    # iterate through expected members, and grab data
    # recurse through each member
    class_order = []
    class_defs  = Dict{String, Vector{Tuple{Symbol, Port}}}()
    grabClassDefinitions(instance, type, class_order, class_defs)

    base_dir   = dirname(path_interface[1])
    model_name = splitext(interface)[1]

    # create text
    hxx_text = "#include <cstdint>\n" *
               "#include <complex>\n" *
               "#include <BaseModel.hxx>\n\n"
    cxx_text = "#include \"$(model_name)_interface.hxx\"\n"
    global _type_map
    for i in length(class_order):-1:1
        name = class_order[i][13:end] # Remove RSIS.MModel. prepend
        fields = class_defs[class_order[i]]
        htext = "class $(name) {\n" *
                "public:\n" *
                "    $name();\n" *
                "    virtual ~$name();\n";
        ctext = "$name::$name()"
        if length(fields) != 0
            ctext = ctext * " : "
        end
        first = true;
        for (n,f) in fields
            htext = htext * "    " * _type_map[f.type] * " " * "$n"
            htext = htext * "; // $(f.note) \n"
            if !first
                ctext = ctext * ", "
            end
            ctext = ctext * "$n($(f.defaultvalue))"
            if first
                first = false;
            end
        end
        htext = htext * "};\n"
        ctext = ctext * "{ }\n$name::~$name() { }\n"
        hxx_text = hxx_text * htext;
        cxx_text = cxx_text * ctext;
    end

    hxx_text = hxx_text * "void Reflect_$(model_name)();\n"
    cxx_text = cxx_text * "void Reflect_$(model_name)() {\n}\n"

    # Model hxx file
    pushtexttofile(base_dir, model_name, "_interface.hxx", hxx_text)

    # Model cxx file
    pushtexttofile(base_dir, model_name, "_interface.cxx", cxx_text)

    println("Generation complete")
    return
end

end
