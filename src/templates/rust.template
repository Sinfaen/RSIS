// Autogenerated by the RSIS Framework

extern crate modellib;
extern crate libc;
extern crate rmp_serde;
extern crate rmpv;

use libc::c_char;

use modellib::BufferStruct;
use std::slice::Iter;

{{STRUCT_DEFINITIONS}}

{{CONSTRUCTOR_DEFINITIONS}}

{{SERIALIZATION}}

{{DESERIALIZATION}}

pub static METADATA : &str = "\
{{METADATA_TOML}}\0";

#[no_mangle]
pub extern "C" fn metadata() -> *const c_char {
    METADATA.as_ptr() as *const c_char
}

pub fn handle_msg_get(interface : &{{NAME}}, id : BufferStruct, data : BufferStruct) -> u32 {
    let indices = unsafe { std::slice::from_raw_parts(id.ptr as *const u32, id.size) };
    let slice = unsafe { std::slice::from_raw_parts_mut(data.ptr as *mut u8, data.size) };
    match s_height_sensor(&interface, indices.iter()) {
        Ok(packed) => {
            if packed.len() != data.size {
                return 2;
            }
            // copy data
            slice.clone_from_slice(packed.as_slice());
        },
        _ => {
            return 1;
        }
    }
    return 0;
}

pub fn handle_msg_set(interface : &mut {{NAME}}, id : BufferStruct, data : BufferStruct) -> u32 {
    let indices = unsafe { std::slice::from_raw_parts(id.ptr as *const u32, id.size) };
    let slice = unsafe { std::slice::from_raw_parts(data.ptr, data.size) };
    match d_height_sensor(interface, indices.iter(), slice) {
        Some(_) => {
            println!("Something went wrong!");
            return 1;
        },
        None => {
            return 0; // success!
        }
    }
}